:PROPERTIES:
:PostTags: Haskell, Julia Evans, DNS
:END:
#+Title: Implement DNS in a Weekend (in Haskell)

* Part 1: Build a DNS Query
** 1.1: DNSHeader and DNSQuestion Types

My ~DNSHeader~ and ~DNSQuestion~ types are slightly different – I used ~Word16s~ in place of ~ints~ as the values can only be positive, and added more specific types for a few of the fields.

#+name: dns-header-data
#+begin_src haskell
  data DNSHeader = DNSHeader
    { queryID :: Word16
    , flags :: DNSHeaderFlags
    , numQuestions :: Word16
    , numAnswers :: Word16
    , numAuthorities :: Word16
    , numAdditionals :: Word16
    } deriving (Show, Eq, Generic)
#+end_src

#+name: dns-question-data
#+begin_src haskell
  data DNSQuestion = DNSQuestion
    { name :: DNSDomain
    , type_ :: RecordType
    , class_ :: Word16
    } deriving (Show, Eq, Generic)
#+end_src

For the ~DNSHeaderFlags~, I modelled the flags I needed and ignored the rest.

#+name: dns-header-flags-data
#+begin_src haskell
  data DNSHeaderFlags = DNSHeaderFlags
    { queryOrReply :: QueryOrReply
    , recursionDesired :: Bool
    } deriving (Show, Eq, Generic)
#+end_src

Using an explicit sum type for ~QueryOrReply~ (rather than a ~Boolean~) made it easier for me to remember which value corresponded to 0 and which to 1.

#+name: query-or-reply-data
#+begin_src haskell
  data QueryOrReply = Query | Reply deriving (Show, Eq)
#+end_src

Thinking of [[https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/][parse, don’t validate]], I represented a domain as a separated list of labels.

#+name: dns-domain-data
#+begin_src haskell
  newtype DNSDomain = DNSDomain [Text]
    deriving (Show, Eq, Generic)
#+end_src

** 1.2: Conversions to Bytes

For a replacement for Python’s ~struct.pack~, I’ve used the ~binary~ library. In the simplest cases like ~DNSHeader~, the ~Generic~-derived ~Binary~ instance can be used.

#+name: dns-header-binary-instance
#+begin_src haskell
  instance Binary DNSHeader
#+end_src

For more complicated cases like ~DNSHeaderFlags~ (since I separated the flags out into their own fields and types), a custom instance is necessary.

#+name: dns-header-flags-binary-instance
#+begin_src haskell
  instance Binary DNSHeaderFlags where
    get = do
      word <- get
      return DNSHeaderFlags
        { queryOrReply = word ^. queryOrReply'
        , recursionDesired = word ^. recursionDesired'
        }
    put DNSHeaderFlags{..} = put (zeroBits
                                 & (queryOrReply' .~ queryOrReply)
                                 . (recursionDesired' .~ recursionDesired)
                                 )
#+end_src

This depends on the lenses ~queryOrReply'~ and ~recursionDesired'~, which map the flags to a bit in a 2-byte word.

#+name: dns-header-flags-lenses
#+begin_src haskell
  queryOrReply' :: Lens' Word16 QueryOrReply
  queryOrReply' = bit 15 . iso fromBool toBool
    where
      toBool Query = False
      toBool Reply = True
      fromBool = bool Query Reply

  recursionDesired' :: Lens' Word16 Bool
  recursionDesired' = bit 8

  bit :: Bits w => Int -> Lens' w Bool
  bit n = lens (flip testBit n) (\word -> bool (clearBit word n) (setBit word n))
#+end_src

~Binary~ instances always use network order for their encoding, so there’s no need to explicitly specify it.

** 1.3: Encoding and Decoding ~DNSDomains~

For ~DNSDomains~, the encoding and decoding is more complicated, so I used the underlying ~Get~ and ~Put~ monads rather than the ~Binary~ class. Getting and putting individual fragments and uncompressed domains is straightforward, reading or writing a length prefix and then the data of that length. (~getDomainFragment~ also returns the location the fragment was read at, to facilitate the domain name compression.)

#+name: get-and-put-domain-fragment
#+begin_src haskell
  getDomainFragment :: Get (Maybe (Int64, Either UnicodeException Text))
  getDomainFragment = do
    location <- bytesRead
    LengthPrefixed{..} <- get @(LengthPrefixed Word8)
    return (if ByteString.null data_
      then Nothing
      else (Just (location, decodeUtf8' data_)))

  putUncompressedDomain :: DNSDomain -> Put
  putUncompressedDomain (DNSDomain fragments) = do
    let putFragment f =
          put (lengthPrefixed @Word8 (encodeUtf8 f))
    _ <- traverse putFragment fragments
    put (zeroBits :: Word8)
#+end_src

For length-prefixed bytestrings (with different size types for representing the length), I made a wrapper type ~LengthPrefixed~.

#+name: length-prefixed
#+begin_src haskell
  lengthPrefixed :: Num l => ByteString -> LengthPrefixed l
  lengthPrefixed data_ = let
    length = fromIntegral (ByteString.length data_)
    in LengthPrefixed{..}

  data LengthPrefixed l = LengthPrefixed
    { length :: l
    , data_ :: ByteString
    }
    deriving (Show, Eq, Generic)

  instance (Binary l, Integral l) => Binary (LengthPrefixed l) where
    get = do
      numberOfBytes <- get
      bytes <- replicateM (fromIntegral numberOfBytes) get
      return (LengthPrefixed numberOfBytes (ByteString.pack bytes))

    put (LengthPrefixed l bs) = do
      put l
      putByteString bs
#+end_src

*** ~DNSDomain~ Compression

Implementing compression for domain names in a purely functional manner was fun: instead of following a pointer to earlier in the buffer and reading there, I kept a map of all domain names read so far keyed by their position in the buffer, reading out of that when encountering a pointer. (This won’t work if the pointer points to a later position in the buffer, but that situation never came up. Maybe it’s not allowed by the spec, or maybe it’s just rare?)

#+name: get-domain
#+begin_src haskell
  type WithDomainCache a = State (Map Word16 DNSDomain) a

  getDomain :: Get (WithDomainCache ([UnicodeException], DNSDomain))
  getDomain = do
    length <- lookAhead getWord8
    if testBit length 7 && testBit length 6
    then do
      f <- followDomainPointer
      return (state (\m -> (([], f m), m)))
    else
      getDomainFragment >>=
        (\case
          Nothing -> return (return ([], DNSDomain []))
          Just (location, fragment) -> do
            f <- getDomain
            return do
              (es, DNSDomain tail) <- f
              case fragment of
                Left e -> do
                  modify (Map.insert (fromIntegral location) (DNSDomain tail))
                  return (e : es, DNSDomain tail)
                Right text -> do
                  let newDomain = DNSDomain (text : tail)
                  modify (Map.insert (fromIntegral location) newDomain)
                  return (es, newDomain))

  followDomainPointer :: HasCallStack => Get (Map Word16 DNSDomain -> DNSDomain)
  followDomainPointer = do
    w :: Word16 <- get
    let pointer = w `clearBit` 15 `clearBit` 14
    return (\map ->
              fromMaybe (error ("Couldn't find location " <> show pointer <> " in domain map: " <> show map))
              (Map.lookup pointer map))
#+end_src

* Main file

#+begin_src haskell :tangle app/Main.hs :noweb yes
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE LambdaCase #-}
  {-# LANGUAGE TypeApplications #-}
  {-# LANGUAGE BlockArguments #-}
  {-# LANGUAGE DeriveGeneric #-}
  {-# LANGUAGE DuplicateRecordFields #-}
  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE RecordWildCards #-}
  module Main where

  import Prelude hiding (map, length, tail)

  import Control.Category hiding ((.), id)
  import Control.Lens
  import Control.Monad
  import Control.Monad.Trans.State.Strict hiding (put, get)
  import Data.Binary
  import Data.Binary.Get
  import Data.Binary.Put
  import Data.Bits hiding (bit)
  import Data.Bool
  import Data.ByteString hiding (split, length, tail)
  import Data.ByteString qualified as ByteString
  import Data.Foldable hiding (length)
  import Data.Generics.Product (field)
  import Data.Int
  import Data.List as List hiding (length, tail, map)
  import Data.Map.Strict as Map
  import Data.Maybe
  import Data.Text as Text hiding (length, tail)
  import Data.Text.Encoding (encodeUtf8, decodeUtf8')
  import Data.Text.Encoding.Error
  import GHC.Generics hiding (from, to)
  import GHC.Stack
  import Network.Socket
  import Network.Socket.ByteString
  import System.Random

  main :: IO ()
  main = do
    gen <- getStdGen
    (response, _) <- resolve gen (domainFromText "www.facebook.com") A
    print response

  resolve :: RandomGen g => g -> DNSDomain -> RecordType -> IO (Either String (Word8, Word8, Word8, Word8), g)
  resolve gen domain recordType = query gen (198, 41, 0, 4)
    where
      query :: RandomGen g => g -> (Word8, Word8, Word8, Word8) -> IO (Either String (Word8, Word8, Word8, Word8), g)
      query gen ns = do
        putStrLn ("Querying " <> show ns <> " for " <> showDomain domain)
        (response, gen) <- sendQuery gen ns domain recordType
        case fmap firstAnswer response of
          Right (Just (Left ip)) -> return (Right ip, gen)
          Right (Just (Right d)) -> resolve gen d A
          Right Nothing -> case fmap firstNameserverIp response of
            Right (Just DNSRecord{data_ = IPv4 ns}) -> query gen ns
            Right Nothing -> case fmap firstNameserver response of
              Right Nothing -> return (Left ("No answer or nameserver in: " <> show response), gen)
              Right (Just ns) -> do
                (result, gen) <- resolve gen ns A
                case result of
                  Left e -> return (Left ("Couldn’t resolve nameserver (" <> show ns
                                          <> ") needed in resolving domain (" <> showDomain domain
                                          <> ") due to error (" <> e <> ")"), gen)
                  Right record -> query gen record
              _ -> return (Left "Unknown problem", gen)
            _ -> return (Left "Unknown problem", gen)
          Left s -> return (Left ("DNS problem: " <> s), gen)

  firstAnswer :: DNSPacket -> Maybe (Either (Word8, Word8, Word8, Word8) DNSDomain)
  firstAnswer DNSPacket{..} = do
    DNSRecord{..} <- List.find (^. field @"type_" . to (`List.elem` [A, CNAME])) answers
    case data_ of
      IPv4 ns -> Just (Left ns)
      DomainName n -> Just (Right n)
      _ -> Nothing

  firstNameserverIp :: DNSPacket -> Maybe DNSRecord
  firstNameserverIp DNSPacket{..} = List.find (^. field @"type_" . to (== A)) additionals

  firstNameserver :: DNSPacket -> Maybe DNSDomain
  firstNameserver DNSPacket{..} = do
    DNSRecord{..} <- List.find (^. field @"type_" . to (== NS)) authorities
    case data_ of
      DomainName n -> Just n
      _ -> Nothing

  sendQuery :: RandomGen g => g -> (Word8, Word8, Word8, Word8) -> DNSDomain -> RecordType -> IO (Either String DNSPacket, g)
  sendQuery gen server domain recordType = do
    s <- socket AF_INET Datagram defaultProtocol
    let (query, gen') = buildQuery gen domain recordType
    connect s (SockAddrInet 53 (tupleToHostAddress server))
    sendAll s query
    response <- recv s 1024
    _ <- close s
    let result = case runGetOrFail getDNSPacket (fromStrict response) of
          Left (_, _, e) -> Left e
          Right (_, _, ([], p)) -> Right p
          Right (_, _, (es, _)) -> Left ("Got UnicodeExceptions processing domain names: " <> show es)
    return (result, gen')

  data DNSPacket = DNSPacket
    { header :: DNSHeader
    , questions :: [DNSQuestion]
    , answers :: [DNSRecord]
    , authorities :: [DNSRecord]
    , additionals :: [DNSRecord]
    } deriving (Show, Eq, Generic)

  getDNSPacket :: Get ([UnicodeException], DNSPacket)
  getDNSPacket = do
    header@DNSHeader{..} <- get
    getQuestions <- replicateM (fromIntegral numQuestions) getDNSQuestion
    getAnswers <- replicateM (fromIntegral numAnswers) getDNSRecord
    getAuthorities <- replicateM (fromIntegral numAuthorities) getDNSRecord
    getAdditionals <- replicateM (fromIntegral numAdditionals) getDNSRecord
    let
      splitErrors :: [([UnicodeException], a)] -> ([UnicodeException], [a])
      splitErrors xs = (foldMap fst xs, foldMap ((: []) . snd) xs)
    return (fst (flip runState Map.empty do
      (questionErrors, questions) <- splitErrors <$> sequence getQuestions
      (answerErrors, answers) <- splitErrors <$> sequence getAnswers
      (authorityErrors, authorities) <- splitErrors <$> sequence getAuthorities
      (additionalErrors, additionals) <- splitErrors <$> sequence getAdditionals
      let errors = questionErrors <> answerErrors <> authorityErrors <> additionalErrors
      return (errors, DNSPacket{..})))

    -- put DNSPacket{..} = do
    --   put header
    --   foldMap putDNSQuestion questions
    --   foldMap putDNSRecord answers
    --   foldMap putDNSRecord authorities
    --   foldMap putDNSRecord additionals

  <<dns-header-data>>

  <<dns-header-binary-instance>>

  <<dns-header-flags-data>>

  <<dns-header-flags-binary-instance>>

  <<query-or-reply-data>>

  <<dns-header-flags-lenses>>

  <<dns-question-data>>

  putDNSQuestion :: DNSQuestion -> Put
  putDNSQuestion DNSQuestion{..} = do
    putUncompressedDomain name
    putRecordType type_
    put class_

  getDNSQuestion :: Get (WithDomainCache ([UnicodeException], DNSQuestion))
  getDNSQuestion = do
    f <- getDomain
    type_ <- getRecordType
    class_ <- get
    return do
      (errors, name) <- f
      return (errors, DNSQuestion{..})

  classIn :: Word16
  classIn = 1

  <<dns-domain-data>>

  domainFromText :: Text -> DNSDomain
  domainFromText = Text.splitOn "." >>> DNSDomain

  domainToText :: DNSDomain -> Text
  domainToText (DNSDomain ts) = mconcat (List.intersperse "." ts)

  showDomain :: DNSDomain -> String
  showDomain = Text.unpack . domainToText

  <<get-and-put-domain-fragment>>

  <<get-domain>>

  <<length-prefixed>>

  buildQuery :: RandomGen g => g -> DNSDomain -> RecordType -> (ByteString, g)
  buildQuery gen domain recordType = let
    (queryID, gen') = genWord16 gen
    question = DNSQuestion domain recordType classIn
    header = DNSHeader
      { queryID
      , flags = DNSHeaderFlags { queryOrReply = Query, recursionDesired = False }
      , numQuestions = 1
      , numAnswers = 0
      , numAuthorities = 0
      , numAdditionals = 0
      }
    in (toStrict (encode header <> runPut (putDNSQuestion question)), gen')

  data DNSRecord = DNSRecord
    { name :: DNSDomain
    , type_ :: RecordType
    , class_ :: Word16
    , ttl :: Int32
    , data_ :: RecordData
    } deriving (Show, Eq, Generic)

  getDNSRecord :: Get (WithDomainCache ([UnicodeException], DNSRecord))
  getDNSRecord = do
    getName <- getDomain
    type_ <- getRecordType
    class_ <- get
    ttl <- get
    getData_ <- case type_ of
      NS -> skip 2 *> (fmap (fmap DomainName) <$> getDomain)
      CNAME -> skip 2 *> (fmap (fmap DomainName) <$> getDomain)
      A -> do
        addressLength <- get @Word16
        case addressLength of
          4 -> (return . ([], ) . IPv4) <$> ((,,,) <$> get <*> get <*> get <*> get)
          _ -> error "Unexpected IP Address length"
      AAAA -> (return . ([], ) . IPv6) <$> get
      TXT -> (return . ([], ) . RawData) <$> get
      UnrecognisedType _ -> (return . ([], ) . RawData) <$> get
    return do
      (errors, name) <- getName
      (moreErrors, data_) <- getData_
      return (errors <> moreErrors, DNSRecord{..})

  putDNSRecord :: DNSRecord -> Put
  putDNSRecord DNSRecord{..} = do
    putUncompressedDomain name
    putRecordType type_
    put class_
    put ttl
    putRecordData data_

  data RecordType
    = A
    | NS
    | CNAME
    | TXT
    | AAAA
    | UnrecognisedType Word16
    deriving (Show, Eq, Generic)

  typeToWord16 :: RecordType -> Word16
  typeToWord16 = \case
    A -> 1
    NS -> 2
    CNAME -> 5
    TXT -> 16
    AAAA -> 28
    UnrecognisedType n -> n

  typeFromWord16 :: Word16 -> RecordType
  typeFromWord16 = \case
    1 -> A
    2 -> NS
    5 -> CNAME
    16 -> TXT
    28 -> AAAA
    n -> UnrecognisedType n

  putRecordType :: RecordType -> Put
  putRecordType = put . typeToWord16

  getRecordType :: Get RecordType
  getRecordType = typeFromWord16 <$> get

  data RecordData
    = RawData (LengthPrefixed Word16)
    | IPv4 (Word8, Word8, Word8, Word8)
    | IPv6 (LengthPrefixed Word16)
    | DomainName DNSDomain
    deriving (Show, Eq, Generic)

  putRecordData :: RecordData -> Put
  putRecordData = \case
    RawData bs -> put bs
    IPv4 (n1, n2, n3, n4) -> traverse_ put [n1, n2, n3, n4]
    IPv6 bs -> put bs
    DomainName n -> putUncompressedDomain n

  showAsIPAddress :: ByteString -> String
  showAsIPAddress bs =
    mconcat (List.intersperse "." (fmap show (ByteString.unpack bs)))
#+end_src
